# Technical Lesson: Database Migration

In the previous lesson, we used Flask-Migrate (which uses Alembic behind the
scenes) to create an initial version of a database schema that defined a single
table. But we often need to make additional changes to a schema after it has
been defined. For example, we may need to add new tables, add new columns to
existing tables, rename columns, add or change column constraints, etc.
Flask-Migrate is a powerful tool that can generate migrations for many of the
common changes we might make to a database schema, including:

* Creating and dropping tables.
* Creating and dropping columns.
* Most indexing tasks.
* Renaming keys.

That being said, there are certain tasks that Flask-Migrate can help us with but
cannot carry out on its own:

* Table name changes.
* Column name changes.
* Adding, removing, or changing unnamed constraints.
* Converting Python data types that are not supported by the database.

## Scenario

You’ve been hired as a junior backend developer at BrightPath Solutions, a growing consulting firm that manages employee and department data for multiple clients. The initial database for their internal system is in place, but client needs are evolving — they frequently request updates like adding new departments, renaming fields, and adjusting data structures.

Your team wants to avoid manual SQL edits or risky full rebuilds of the database.
Instead, they want a safe and professional migration system to evolve the schema while protecting existing production data.

In this lesson, you’ll learn how to:
* Add new tables and columns.
* Correct mistakes in schema design (like renaming a table or column).
* Roll back changes safely when a migration introduces an error.

To check out the full list of supported commands, make sure you follow the setup
instructions and then type `flask db --help` in the terminal.

## Tools & Resources

- [GitHub Repo](https://github.com/learn-co-curriculum/flask-sqlalchemy-migration-technical-lesson)
- [SQLAlchemy ORM Documentation](https://docs.sqlalchemy.org/en/14/orm/)
- [SQLAlchemy ORM Column Elements and Expressions](https://docs.sqlalchemy.org/en/14/core/sqlelement.html)
- [Tutorial - Alembic](https://alembic.sqlalchemy.org/en/latest/tutorial.html)
- [Operation Reference - Alembic](https://alembic.sqlalchemy.org/en/latest/ops.html)

## Instructions

### Set Up

This lesson is a code-along, so fork and clone the repo.

`Pipfile` has some new dependencies that we'll use in this
lesson:`flask-sqlalchemy`and`flask-migrate`. Run `pipenv install`to install the
dependencies and `pipenv shell` to enter your virtual environment before running
your code.

```console
$ pipenv install
$ pipenv shell
```

Change into the `server` directory and configure the `FLASK_APP` and
`FLASK_RUN_PORT` environment variables:

```console
$ cd server
$ export FLASK_APP=app.py
$ export FLASK_RUN_PORT=5555
```

### Task 1: Define the Problem

In the real world, database schemas are rarely static. New business needs often require you to:

* Add new fields
* Modify existing tables
* Correct naming mistakes
* Revert accidental changes

Manual SQL modifications can be error-prone and dangerous, especially on production data. Flask-Migrate (powered by Alembic) offers a structured way to version control schema changes safely and roll them back when necessary.

Your Challenge is to use Flask-Migrate to:
* Manage multiple schema changes across a real project.
* Correct mistakes without losing existing records.
* Maintain a clean, consistent database schema throughout multiple migrations.

Learning to create and manage database migrations responsibly is a critical skill for developers maintaining long-running applications.

### Task 2: Determine the Design

The technical design for this project will follow these principles:

* Model Changes First: Modify the Python models first (source of truth).
* Autogenerate Migrations: Use flask db migrate to create new migration scripts reflecting model updates.
* Manual Script Editing: Recognize when autogenerated migrations are insufficient (e.g., renaming tables/columns) and manually adjust scripts using Alembic operations (rename_table, alter_column).
* Upgrade and Downgrade: Always verify the migration scripts before applying changes. Downgrade migrations if a mistake is detected.
* Protect Data: Always preserve existing records during migration (avoid destructive changes like dropping tables or columns with existing data).

This approach ensures:

* Flexibility to adapt the database structure safely.
* Clear version history of all schema changes.
* Minimal risk to valuable production data.

### Task 3: Develop, Test, and Refine the Code

#### Step 1: Initial Migration - Employee Model

```text
└── server
    ├── app.py
    ├── models.py
    └── testing
        └── codegrade_test.py
```

The `server` directory contains `models.py`, which defines an `Employee` model:

```py
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import MetaData

# contains definitions of tables and associated schema constructs
metadata = MetaData()

# create the Flask SQLAlchemy extension
db = SQLAlchemy(metadata=metadata)

# define a model class by inheriting from db.Model.


class Employee(db.Model):
    __tablename__ = 'employees'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    salary = db.Column(db.Integer)

    def __repr__(self):
        return f'<Employee {self.id}, {self.name}, {self.salary}>'

```

Let's perform an initial migration to create the database `app.db` with an
`employees` table as described by the `Employee` model.

Make sure you are in the `server` directory, then enter the following commands:

```console
$ flask db init
```

```console
$ flask db migrate -m "Initial migration."
```

At this point, you will see a new migration script `###_initial_migration.py`
show up in the `server/migrations/versions` directory (your version number will
be different):

```text
.
├── app.py
├── instance
│   └── app.db
├── migrations
│   ├── README
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       └── 15537423c56d_initial_migration.py
├── models.py
└── testing
    └── codegrade_test.py
```

As a reminder, the `###_initial_migration.py` script contains two functions
`upgrade()` and `downgrade()`. We can see the `upgrade()` function will create
the `employees` table, while the `downgrade()` script drops it.

```py
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('employees',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('salary', sa.Integer(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('employees')
    # ### end Alembic commands ###
```

Let's execute the `upgrade()` function to create the table.

```console
$ flask db upgrade head
```

Open the database file `server/instance/app.db` using SQLite Viewer (or any
other SQLite extension) and confirm the newly created `employees` table:

![initial migration creates empty employee table](https://curriculum-content.s3.amazonaws.com/7159/python-p4-v2-flask-sqlalchemy/initial.png)

Let's use the Flask shell to add a few employees:

```console
$ flask shell
>>> from models import db, Employee
>>> db.session.add( Employee(name = "Kai Uri", salary = 89000))
>>> db.session.add( Employee(name = "Alena Lee", salary = 125000))
>>> db.session.commit()
>>> Employee.query.all()
[<Employee 1, Kai Uri, 89000>, <Employee 2, Alena Lee, 125000>]
>>> exit()
```

#### Step 2: Second Migration - Department model

In this next step, we will update `models.py` to add a `Department` model. We'll
intensionally make a mistake in assigning the singular table name `department`,
then see how to fix this in a subsequent migration.

Update `models.py` to add the `Department` class as shown:

```py
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import MetaData

# contains definitions of tables and associated schema constructs
metadata = MetaData()

# create the Flask SQLAlchemy extension
db = SQLAlchemy(metadata=metadata)

# define a model class by inheriting from db.Model.


class Employee(db.Model):
    __tablename__ = 'employees'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    salary = db.Column(db.Integer)

    def __repr__(self):
        return f'<Employee {self.id}, {self.name}, {self.salary}>'


class Department(db.Model):
    __tablename__ = 'department'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    address = db.Column(db.String)

    def __repr__(self):
        return f'<Department {self.id}, {self.name}, {self.address}>'
```

Adding a new model means we need to add a new table to the database.

Since we've already inserted some rows into the `employees` table, we **don't
want to delete** the database and recreate the initial migration because we
would lose that data (imagine we inserted millions of rows rather than just
two).

We will migrate the database schema by generating a second migration script to
add the new `department` table, while leaving the existing `employees` table
unmodified. Run `flask db migrate` with a descriptive message that explains the
new change to the schema:

```console
$ flask db migrate -m 'add Department'
```

A new migration script appears in the `migrations/versions` directory (once
again, your version numbers will be different):

```text
.
├── app.py
├── instance
│   └── app.db
├── migrations
│   ├── README
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       ├── 15537423c56d_initial_migration.py
│       └── 51f20aa4768b_add_department.py
├── models.py
└── testing
    └── codegrade_test.py
```

Take a look at the `###_add_department.py` migration script. The `upgrade()` and
`downgrade()` functions will add and drop the `department` table. Notice also
the `down_revision` variable references the version id of the initial migration
script.

```py
"""add Department

Revision ID: 51f20aa4768b
Revises: 15537423c56d
Create Date: 2023-08-02 17:33:01.228058

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '51f20aa4768b'
down_revision = '15537423c56d'
branch_labels = None
depends_on = None

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('department',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('address', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###

def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('department')
    # ### end Alembic commands ###
```

Let's execute this most recent migration script to add the new table by
executing the `upgrade()` function. Recall that `head` refers to the most recent
migration version. Type the following command to execute the
`###_add_department.py` script (i.e. the most recent version).

```console
$ flask db upgrade head
```

Confirm the new `department` table has been added to the database:

![department table added to database](https://curriculum-content.s3.amazonaws.com/7159/python-p4-v2-flask-sqlalchemy/add_department.png)

Now add some departments using Flask shell:

```console
$ flask shell
>>> from models import Department
>>> db.session.add( Department(name = "Payroll", address = "Building A, 4th Floor"))
>>> db.session.add( Department(name = "Human Resources", address = "Building C, 1st Floor"))
>>> db.session.commit()
>>> Department.query.all()
[<Department 1, Payroll, Building A, 4th Floor>, <Department 2, Human Resources, Building C, 1st Floor>]
>>> exit()
```

#### Step 3: Third Migration - Rename department table

Let's fix the error we made in naming the table. Edit `models.py` to change the
table name from `department` to `departments`:

```py
class Department(db.Model):
    __tablename__ = 'departments'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    address = db.Column(db.String)

    def __repr__(self):
        return f'<Department {self.id}, {self.name}, {self.address}>'
```

This represents a necessary change to the schema. In SQL we would execute an
`ALTER TABLE` command. However, we can try to have Flask-Migrate do the work for
us.

Type the following to generate a new migration script:

```console
flask db migrate -m "rename department"
```

This results in a new script in `migrations/versions`:

```text
.
├── app.py
├── instance
│   └── app.db
├── migrations
│   ├── README
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       ├── 15537423c56d_initial_migration.py
│       ├── 1694ecedb24d_rename_department.py
│       └── 51f20aa4768b_add_department.py
├── models.py
└── testing
    └── codegrade_test.py
```

**DON'T run `flask db upgrade head` yet!**

It is always a good idea to check the migration script before performing a
migration. Open up the new migration script `###_rename_department.py`:

```py
"""rename department

Revision ID: 1694ecedb24d
Revises: 51f20aa4768b
Create Date: 2023-08-02 18:19:06.373953

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '1694ecedb24d'
down_revision = '51f20aa4768b'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('departments',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('address', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.drop_table('department')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('department',
    sa.Column('id', sa.INTEGER(), nullable=False),
    sa.Column('name', sa.VARCHAR(), nullable=False),
    sa.Column('address', sa.VARCHAR(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.drop_table('departments')
    # ### end Alembic commands ###

```

Notice the `upgrade()` function wants to drop the existing `department` table
and create a new `departments` table. This is not what we want since we already
added rows to the `department` table.

We want to rename the existing table, not drop and create a new one. In SQL, we
would use the `ALTER TABLE` statement. We can achieve the same thing by calling
the Alembic function `rename_table()`.

Edit the `upgrade()` and `downgrade()` functions as shown. The `rename_table()`
function takes two parameters, the old table name and the new table name:

```py
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.rename_table('department', 'departments')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.rename_table('departments', 'department')
    # ### end Alembic commands ###
```

Save the file, then run the upgrade command:

```console
flask db upgrade head
```

Confirm the table has been renamed from `department` to `departments` and that
the 2 rows are still in the table:

![rename department table](https://curriculum-content.s3.amazonaws.com/7159/python-p4-v2-flask-sqlalchemy/rename_departments.png)

#### Step 4: Fourth Migration - Rename address column

We saw that Flask-Migrate generates correct migration code when we added a new
model `Department` to the schema. Flask-Migrate also generates correct code if
we add a new column to an existing model.

However,renaming a column will require a manual update to the migration script,
similar to renaming a table.

Let's rename the `address` column as `location`. Edit `models.py` to change the
attribute name (and update `__repr__`):

```py
class Department(db.Model):
    __tablename__ = 'departments'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    location = db.Column(db.String, nullable=False)

    def __repr__(self):
        return f'<Department {self.id}, {self.name} {self.location}>'
```

Generate a new migration script:

```console
flask db migrate -m "rename address"
```

```console
.
├── app.py
├── instance
│   └── app.db
├── migrations
│   ├── README
│   ├── alembic.ini
│   ├── env.py
│   ├── script.py.mako
│   └── versions
│       ├── 15537423c56d_initial_migration.py
│       ├── 1694ecedb24d_rename_department.py
│       ├── 51f20aa4768b_add_department.py
│       └── 76f31678b786_rename_address.py
├── models.py
└── testing
    └── codegrade_test.py
```

Open the new `###_rename_address.py` file to see the auto-generated `upgrade()`
and `downgrade()` functions:

```py
def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('departments', schema=None) as batch_op:
        batch_op.add_column(sa.Column('location', sa.String(), nullable=True))
        batch_op.drop_column('address')

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('departments', schema=None) as batch_op:
        batch_op.add_column(sa.Column('address', sa.VARCHAR(), nullable=True))
        batch_op.drop_column('location')
```

The `batch_alter_table` function is called to execute the `add_column()` and
`drop_column()` functions as a transaction.

But we don't want to drop the column at all since that will cause us to lose the
data in the 2 existing rows! Instead, we will rename the column from `address`
to `location` using the `alter_column()` function. Edit the migration script to
call `alter_column()` as shown:

```py

def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('departments', 'address',  new_column_name='location')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('departments', 'location',  new_column_name='address')
    # ### end Alembic commands ###
```

Now we can upgrade the schema to rename the column from `address` to `location`:

```console
flask db upgrade head
```

![rename column](https://curriculum-content.s3.amazonaws.com/7159/python-p4-v2-flask-sqlalchemy/rename_address.png)

#### Step 5: Downgrading/Reverting a migration

Sometimes we might want to undo a schema migration and return to a previous
version.

This was the order of the migration versions that we performed:

1. ###\_initial_migration.py
2. ###\_add_department.py
3. ###\_rename_department.py
4. ###\_rename_address.py

Suppose we decide to revert the column name from `location` back to `address`.
We would like to undue the most recent changes performed by
`###_rename_address.py` and return the schema to the state it was in the
previous version `###_rename_department.py`

Open the most recent version `###_rename_address.py` and look at the value of
the variable `down_revision`. Your number will be different:

```py
"""rename address

Revision ID: 76f31678b786
Revises: 1694ecedb24d
Create Date: 2023-08-02 18:52:31.603713

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '76f31678b786'
down_revision = '1694ecedb24d'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('departments', 'address',  new_column_name='location')
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.alter_column('departments', 'location',  new_column_name='address')
    # ### end Alembic commands ###

```

The `downgrade()` function will basically undo the column renaming and return us
to the previous version as defined by `down_revision`.

Execute the following command (substituting ### for the version number specified
by `down_version`):

```console
flask db downgrade ###
```

This should rename the `location` column back to `address`.

You may need to hit the refresh button to see that change:

![rename department table](https://curriculum-content.s3.amazonaws.com/7159/python-p4-v2-flask-sqlalchemy/rename_departments.png)

Note: You should also update `models.py` to rename the variable back to the
original `address` (and revert `__repr__`).

#### Step 6: Verify your Code

The final version of `models.py` should look like:

```py
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import MetaData

# contains definitions of tables and associated schema constructs
metadata = MetaData()

# create the Flask SQLAlchemy extension
db = SQLAlchemy(metadata=metadata)

# define a model class by inheriting from db.Model.


class Employee(db.Model):
    __tablename__ = 'employees'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    salary = db.Column(db.Integer)

    def __repr__(self):
        return f'<Employee {self.id}, {self.name}, {self.salary}>'

class Department(db.Model):
    __tablename__ = 'departments'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String, nullable=False)
    address = db.Column(db.String)

    def __repr__(self):
        return f'<Department {self.id}, {self.name}, {self.address}>'
```

### Step 7: Commit, Push, and (if using branching) Merge

* Commit and Push your final code to GitHub

```bash
git add .
git commit -m ""
git push origin <main or feature branch name>
```

* Open a PR and Merge if using a feature branch

### Task 4:

Best Practice documentation steps:
* Add comments to the code to explain purpose and logic, clarifying intent and functionality of your code to other developers.
* Update README text to reflect the functionality of the application following https://makeareadme.com. 
  * Add screenshot of completed work included in Markdown in README.
* Delete any stale branches on GitHub
* Remove unnecessary/commented out code
* If needed, update git ignore to remove sensitive data

## Considerations

When managing database migrations, keep the following in mind:

* Data Integrity Risks: Dropping or recreating tables/columns without backups can cause irreversible data loss.
* Manual Edits Are Necessary: Flask-Migrate can't automatically detect every change (especially renaming tables/columns); developers must edit migration scripts manually.
* Downgrades Require Care: Downgrading a migration only reverts the schema. It doesn’t automatically restore any data that may have been deleted by an earlier mistake.
* Migration Review is Mandatory: Always open and review the autogenerated migration scripts before running flask db upgrade head.
* Best Practices: When possible, use non-destructive operations like rename_table or alter_column instead of dropping and recreating.
* Consistent Naming Conventions: Be thoughtful when naming models and tables initially — frequent renaming causes migration complexity.

Learning to read, edit, and manage migration scripts manually is a hallmark of a professional backend developer.